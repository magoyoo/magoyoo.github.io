{"pageProps":{"data":{"title":"[번역] Stack Views","description":"apple 공식 문서인 Auto Layout Guide 중 Stack Views Chapter를 번역한 글입니다.","date":"2023-04-27T18:20:40.322Z","tags":["swift","auth layout","document","번역","UIKit"],"author":"마고유","img":{"src":"/_next/static/image/src/assets/blog/autoPost/autoPost05/image06.4da0f06fab37cf2d7cf3e695e3db3cff.jpg","height":482,"width":900,"blurDataURL":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoKCgoKCgsMDAsPEA4QDxYUExMUFiIYGhgaGCIzICUgICUgMy03LCksNy1RQDg4QFFeT0pPXnFlZXGPiI+7u/sBCgoKCgoKCwwMCw8QDhAPFhQTExQWIhgaGBoYIjMgJSAgJSAzLTcsKSw3LVFAODhAUV5PSk9ecWVlcY+Ij7u7+//CABEIAAQACAMBIgACEQEDEQH/xAAUAAEAAAAAAAAAAAAAAAAAAAAH/9oACAEBAAAAAFr/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oACAECEAAAAH//xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oACAEDEAAAAH//xAAcEAABAwUAAAAAAAAAAAAAAAARAAISFCUxMkH/2gAIAQEAAT8AFwMnCn15lf/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Af//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Af//Z"},"project":"swift auto layout","readMin":40,"totalCnt":0,"monthlyCnt":0,"weeklyCnt":0,"category":"swift"},"content":"\n&nbsp;\n&nbsp;\n\n# 개요\n\n---\n\n> 해당 문서는 학습 목적으로 Apple 공식 문서인 [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)을 번역한 글입니다. 다소 오역이 있을 수 있어 잘못된 내용이 있을 수 있습니다. 문제가 되거나 오류가 있다면 댓글 부탁드립니다.\n\n&nbsp;\n\n# 내용\n\n---\n\n지금부터 살펴 볼 예제는 StackView를 사용하여 점점 더 복잡해지는 레이아웃을 만드는 방법입니다. 스택 뷰는 사용자 인터페이스를 빠르고 쉽게 디자인할 수 있는 강력한 도구입니다. 속성(attributes)을 사용하면 정렬된 뷰를 배치하는 방법에 대해 높은 수준의 제어가 가능합니다. 추가적인 커스텀 제약 조건을 사용하여 이러한 설정을 보완할 수 있습니다. 그러나 이것은 레이아웃의 복잡성을 증가시킵니다.\n\n이러한 레시피의 소스 코드를 보려면 [Auto Layout Cookbook](https://developer.apple.com/sample-code/xcode/downloads/Auto-Layout-Cookbook.zip) 프로젝트를 참조하십시오.\n\n&nbsp;\n\n# 간단한 StackView\n\n---\n\n이 예시는 단일 수직 StackView를 사용하여 레이블, 이미지 보기 및 버튼을 배치합니다.\n\n&nbsp;\n![image01](auto0501)\n&nbsp;\n\n## View 와 Constraints\n\nInterface Builder에서 수직 스택 뷰를 드래그하여 시작하고 꽃 레이블, 이미지 뷰 및 편집 버튼을 추가합니다. 그런 다음 그림과 같이 제약 조건을 설정합니다.\n\n&nbsp;\n![image02](auto0502)\n&nbsp;\n\n1. Stack View.Leading = Superview.LeadingMargin\n2. Stack View.Trailing = Superview.TrailingMargin\n3. Stack View.Top = Top Layout Guide.Bottom + Standard\n4. Bottom Layout Guide.Top = Stack View.Bottom + Standard\n\n&nbsp;\n\n#\n\n## 속성(Attributes)\n\nAttributes inspector에서 다음 StackView의 속성을 설정합니다.\n\n&nbsp;\n![image03](auto0503)\n&nbsp;\n\n다음으로 ImageView 에서 다음 속성(Attributes)을 설정합니다.\n\n&nbsp;\n![image04](auto0504)\n&nbsp;\n\n마지막으로 크기 속성에서 ImageView의 content-hugging와 compression-resistance(CHCR)의 우선 순위를 설정합니다.\n\n&nbsp;\n![image05](auto0505)\n&nbsp;\n\n## Discussion\n\nStackView를 부모 View에 고정해야 하지만 그렇지 않으면 StackView가 다른 명시적 제약 없이 전체 레이아웃을 관리합니다.\n\n이 예제에서 StackView는 작은 표준 여백으로 부모View를 채웁니다. 배열된 뷰는 StackView의 경계를 채우기 위해 크기가 조정됩니다. 수평으로 각 뷰는 StackView의 너비와 일치하도록 늘어납니다. 세로로 보기는 CHCR 우선 순위에 따라 늘어납니다. ImageView는 사용 가능한 공간을 채우기 위해 항상 축소되고 커져야 합니다. 따라서 수직 콘텐츠 CHCR 우선 순위는 레이블 및 버튼의 기본 우선 순위보다 낮아야 합니다.\n\n마지막으로 이미지 뷰의 모드를 Aspect Fit으로 설정합니다. 이 설정은 이미지의 종횡비를 유지하면서 ImageView의 경계 내에 맞도록 ImageView가 이미지 크기를 조정하도록 강제합니다. 이를 통해 StackView는 이미지를 왜곡하지 않고 ImageView의 크기를 임의로 조정할 수 있습니다.\n\nView를 고정하여 상위 View를 채우는 방법에 대한 자세한 내용은 [Attributes](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithSimpleConstraints.html#//apple_ref/doc/uid/TP40010853-CH12-SW5) 및 [Adaptive Single View](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithSimpleConstraints.html#//apple_ref/doc/uid/TP40010853-CH12-SW4) 를 참조하세요.\n\n&nbsp;\n\n# Nested Stack Views\n\n---\n\n이 예제는 중첩된 스택 뷰의 여러 레이어에서 빌드된 복잡한 레이아웃을 보여줍니다. 그러나 이 예에서 스택 뷰는 원하는 동작을 단독으로 생성할 수 없습니다. 대신 레이아웃을 더 세분화하려면 추가 제약 조건이 필요합니다.\n\n&nbsp;\n![image06](auto0506)\n&nbsp;\n\n## Views and Constraints\n\n중첩된 스택 뷰로 작업할 때 안쪽에서 바깥쪽으로 작업하는 것이 가장 쉽습니다. Interface Builder에서 이름 행을 배치하여 시작하십시오. 레이블과 텍스트 필드를 올바른 상대 위치에 배치하고 둘 다 선택한 다음 Editor > Embed In > Stack View 메뉴 항목을 클릭합니다. 이렇게 하면 행에 대한 수평 스택 뷰가 생성됩니다.\n\n그런 다음 이 행을 가로로 배치하고 선택하고 Editor > Embed In > Stack View 메뉴 항목을 다시 클릭합니다. 이렇게 하면 행의 가로 스택이 생성됩니다. 표시된 대로 인터페이스를 계속 빌드합니다.\n\n&nbsp;\n![image07](auto0507)\n&nbsp;\n\n1. Root Stack View.Leading = Superview.LeadingMargin\n2. Root Stack View.Trailing = Superview.TrailingMargin\n3. Root Stack View.Top = Top Layout Guide.Bottom + 20.0\n4. Bottom Layout Guide.Top = Root Stack View.Bottom + 20.0\n5. Image View.Height = Image View.Width\n6. First Name Text Field.Width = Middle Name Text Field.Width\n7. First Name Text Field.Width = Last Name Text Field.Width\n\n&nbsp;\n\n##\n\n## Attributes\n\n각 스택에는 자체 속성 세트가 있습니다. 스택이 내용을 배치하는 방법을 정의합니다. 속성 관리자에서 다음 속성을 설정합니다.\n\n&nbsp;\n![image08](auto0508)\n&nbsp;\n\n또한 텍스트 뷰에 밝은 회색 배경색을 지정합니다. 이렇게 하면 방향이 변경될 때 텍스트 뷰의 크기가 어떻게 조정되는지 더 쉽게 확인할 수 있습니다.\n\n&nbsp;\n![image09](auto0509)\n&nbsp;\n\n마지막으로 CHCR 우선 순위는 사용 가능한 공간을 채우기 위해 확장해야 하는 뷰를 정의합니다. 크기 속성에서 다음 CHCR 우선순위를 설정합니다.\n\n&nbsp;\n![image10](auto0510)\n&nbsp;\n\n## Discussion\n\n이 예시에서 스택 뷰는 함께 작동하여 대부분의 레이아웃을 관리합니다. 그러나 그들은 스스로 원하는 행동을 모두 만들 수는 없습니다. 예를 들어, 이미지 뷰의 크기가 조정될 때 이미지는 종횡비를 유지해야 합니다. 안타깝게도 Simple Stack View에서 사용되는 기술은 여기서는 작동하지 않습니다. 레이아웃은 이미지의 후행 가장자리와 아래쪽 가장자리에 모두 맞아야 하며 Aspect Fit 모드를 사용하면 해당 치수 중 하나에 추가 공백이 추가됩니다. 다행스럽게도 이 예에서 이미지의 종횡비는 항상 정사각형이므로 이미지가 이미지 뷰의 경계를 완전히 채우고 이미지 뷰를 1:1 종횡비로 제한할 수 있습니다.\n\n&nbsp;\n\n> NOTE\n>\n> Interface Builder에서 aspect ratio 제약 조건은 단순히 뷰의 높이와 너비 사이의 제약 조건입니다. Interface Builder는 여러 가지 방법으로 제약 조건의 승수를 표시할 수도 있습니다. 일반적으로 종횡비 제약 조건의 경우 비율로 표시됩니다. 따라서 View.Width = View.Height 제약 조건은 1:1 종횡비로 나타날 수 있습니다.\n\n&nbsp;\n\n또한 모든 텍스트 필드의 너비는 동일해야 합니다. 안타깝게도 모두 별도의 스택 뷰에 있으므로 스택에서 이를 관리할 수 없습니다. 대신 동일한 너비 제약 조건을 명시적으로 추가해야 합니다.\n\n단순 스택 뷰와 마찬가지로 일부 CHCR 우선순위도 수정해야 합니다. 이들은 부모클래스의 경계가 변경됨에 따라 뷰가 축소되고 증가하는 방법을 정의합니다.\n\n수직으로 텍스트 뷰가 확장되어 위쪽 스택과 버튼 스택 사이의 공간을 채우려고 합니다. 따라서 텍스트 뷰의 수직 콘텐츠 허깅은 다른 수직 콘텐츠 허깅 우선 순위보다 낮아야 합니다.\n\n수평으로 레이블은 고유 콘텐츠 크기로 나타나야 하며 텍스트 필드는 추가 공간을 채우기 위해 크기가 조정됩니다. 기본 CHCR 우선 순위는 레이블에 적합합니다. Interface Builder는 이미 콘텐츠 허깅을 251로 설정하여 텍스트 필드보다 높게 만듭니다. 그러나 텍스트 필드의 가로 콘텐츠 허깅과 가로 compression resistance을 모두 낮춰야 합니다.\n\n이미지 뷰는 이름 행을 포함하는 스택과 높이가 같도록 축소되어야 합니다. 그러나 스택 뷰는 콘텐츠를 느슨하게 포함할 뿐입니다. 이것은 이미지 뷰의 수직 압축 저항이 매우 낮아야 함을 의미하므로 스택 뷰가 확장되는 대신 이미지 뷰가 축소됩니다. 또한 이미지 뷰의 Aspect ratio 제약 조건은 수직 및 수평 제약 조건이 상호 작용할 수 있기 때문에 레이아웃을 복잡하게 만듭니다. 즉, 텍스트 필드의 가로 콘텐츠 허깅도 매우 낮아야 합니다. 그렇지 않으면 이미지 뷰가 축소되는 것을 방지할 수 있습니다. 두 경우 모두 우선순위를 48 이하의 값으로 설정하십시오.\n\n&nbsp;\n\n# Dynamic Stack View\n\n---\n\n이 예시는 런타임 시 스택에서 항목을 동적으로 추가하고 제거하는 방법을 보여줍니다. 스택에 대한 모든 변경 사항은 애니메이션으로 표시됩니다. 또한 스택 뷰는 스크롤 뷰 안에 배치되어 목록이 너무 길어서 화면에 맞지 않는 경우 목록을 스크롤할 수 있습니다.\n\n&nbsp;\n![image11](auto0511)\n&nbsp;\n\n> NOTE\n>\n> 이 예시는 스택 뷰로 동적으로 작업하고 스크롤 뷰 내에서 스택 뷰로 작업하는 것을 보여주기 위한 것입니다. 실제 앱에서 이 레시피의 동작은 대신 UITableView 클래스를 사용하여 구현해야 합니다. 일반적으로 동적 스택 뷰를 사용하여 스크래치로 만든 테이블 뷰 복제본을 간단히 구현해서는 안 됩니다. 대신 다른 기술로는 쉽게 구축할 수 없는 동적 사용자 인터페이스를 만드는 데 사용하십시오.\n\n&nbsp;\n\n## Views and Constraints\n\n초기 사용자 인터페이스는 매우 간단합니다. 장면에 스크롤 보기를 배치하고 장면을 채우도록 크기를 조정합니다. 그런 다음 스크롤 뷰 내부에 스택 뷰를 배치하고 스택 뷰 내부에 항목 추가 버튼을 배치합니다. 모든 것이 제자리에 있는 즉시 다음 제약 조건을 설정합니다.\n\n&nbsp;\n![image12](auto0512)\n&nbsp;\n\n1. Scroll View.Leading = Superview.LeadingMargin\n2. Scroll View.Trailing = Superview.TrailingMargin\n3. Scroll View.Top = Superview.TopMargin\n4. Bottom Layout Guide.Top = Scroll View.Bottom + 20.0\n5. Stack View.Leading = Scroll View.Leading\n6. Stack View.Trailing = Scroll View.Trailing\n7. Stack View.Top = Scroll View.Top\n8. Stack View.Bottom = Scroll View.Bottom\n9. Stack View.Width = Scroll View.Width\n\n&nbsp;\n\n##\n\n## Attributes\n\nAttributes inspector에서 다음 스택 뷰 속성을 설정합니다.\n\n&nbsp;\n![image13](auto0513)\n&nbsp;\n\n## Code\n\n이 예시에는 스택 뷰에 항목을 추가하고 제거하기 위한 약간의 코드가 필요합니다. 스크롤 뷰와 스택 뷰 모두에 대한 아웃렛이 있는 장면에 대한 사용자 지정 뷰 컨트롤러를 만듭니다.\n\n```swift\nclass DynamicStackViewController: UIViewController {\n\n    @IBOutlet weak private var scrollView: UIScrollView!\n    @IBOutlet weak private var stackView: UIStackView!\n\n    // Method implementations will go here...\n\n}\n```\n\n다음으로 viewDidLoad 메서드를 재정의하여 스크롤 뷰의 초기 위치를 설정합니다. 스크롤 뷰의 콘텐츠가 상태 표시줄 아래에서 시작되기를 원합니다.\n\n```swift\noverride func viewDidLoad() {\n    super.viewDidLoad()\n\n    // setup scrollview\n    let insets = UIEdgeInsetsMake(20.0, 0.0, 0.0, 0.0)\n    scrollView.contentInset = insets\n    scrollView.scrollIndicatorInsets = insets\n\n}\n```\n\n이제 항목 추가 버튼에 대한 작업 메서드를 추가합니다.\n\n```swift\n// MARK: Action Methods\n\n@IBAction func addEntry(sender: AnyObject) {\n\n    let stack = stackView\n    let index = stack.arrangedSubviews.count - 1\n    let addView = stack.arrangedSubviews[index]\n\n    let scroll = scrollView\n    let offset = CGPoint(x: scroll.contentOffset.x,\n                         y: scroll.contentOffset.y + addView.frame.size.height)\n\n    let newView = createEntry()\n    newView.hidden = true\n    stack.insertArrangedSubview(newView, atIndex: index)\n\n    UIView.animateWithDuration(0.25) { () -> Void in\n        newView.hidden = false\n        scroll.contentOffset = offset\n    }\n}\n```\n\n이 메서드는 스크롤 뷰에 대한 새 오프셋을 계산한 다음 새 항목 뷰를 만듭니다. 항목 보기가 숨겨지고 스택에 추가됩니다. 숨겨진 뷰는 스택의 모양이나 레이아웃에 영향을 주지 않으므로 스택의 모양은 변경되지 않습니다. 그런 다음 애니메이션 블록에서 뷰가 표시되고 스크롤 오프셋이 업데이트되어 뷰의 모양에 애니메이션을 적용합니다.\n\n항목을 삭제하는 유사한 방법을 추가합니다. 그러나 addEntry 메소드와 달리 이 메소드는 Interface Builder의 어떤 컨트롤에도 연결되지 않습니다. 대신 앱은 뷰가 생성될 때 프로그래밍 방식으로 각 항목 뷰를 이 메서드에 연결합니다.\n\n```swift\nfunc deleteStackView(sender: UIButton) {\n    if let view = sender.superview {\n        UIView.animateWithDuration(0.25, animations: { () -> Void in\n            view.hidden = true\n        }, completion: { (success) -> Void in\n            view.removeFromSuperview()\n        })\n    }\n}\n```\n\n이 방법은 애니메이션 블록에서 뷰를 숨깁니다. 애니메이션이 완료된 후 뷰 계층 구조에서 뷰를 제거합니다. 이렇게 하면 스택의 정렬된 보기 목록에서 보기가 자동으로 제거됩니다.\n\nentry view는 모든 뷰가 될 수 있지만 이 예제에서는 날짜 레이블, 임의의 16진수 문자열이 포함된 레이블 및 삭제 버튼이 포함된 스택 뷰를 사용합니다.\n\n```swift\n// MARK: - Private Methods\nprivate func createEntry() -> UIView {\n    let date = NSDateFormatter.localizedStringFromDate(NSDate(), dateStyle: .ShortStyle, timeStyle: .NoStyle)\n    let number = \"\\(randomHexQuad())-\\(randomHexQuad())-\\(randomHexQuad())-\\(randomHexQuad())\"\n\n    let stack = UIStackView()\n    stack.axis = .Horizontal\n    stack.alignment = .FirstBaseline\n    stack.distribution = .Fill\n    stack.spacing = 8\n\n    let dateLabel = UILabel()\n    dateLabel.text = date\n    dateLabel.font = UIFont.preferredFontForTextStyle(UIFontTextStyleBody)\n\n    let numberLabel = UILabel()\n    numberLabel.text = number\n    numberLabel.font = UIFont.preferredFontForTextStyle(UIFontTextStyleHeadline)\n\n    let deleteButton = UIButton(type: .RoundedRect)\n    deleteButton.setTitle(\"Delete\", forState: .Normal)\n    deleteButton.addTarget(self, action: \"deleteStackView:\", forControlEvents: .TouchUpInside)\n\n    stack.addArrangedSubview(dateLabel)\n    stack.addArrangedSubview(numberLabel)\n    stack.addArrangedSubview(deleteButton)\n\n    return stack\n}\n\nprivate func randomHexQuad() -> String {\n    return NSString(format: \"%X%X%X%X\",\n                    arc4random() % 16,\n                    arc4random() % 16,\n                    arc4random() % 16,\n                    arc4random() % 16\n        ) as String\n}\n```\n\n&nbsp;\n\n## Discussion\n\n이 레시피에서 설명하는 것처럼 런타임 중에 스택 뷰에서 보기를 추가하거나 제거할 수 있습니다. 스택의 레이아웃은 정렬된 뷰 배열의 변경 사항을 보상하기 위해 자동으로 조정됩니다. 그러나 기억할 가치가 있는 몇 가지 중요한 사항이 있습니다.\n\n-   hidden 뷰는 여전히 스택의 정렬된 뷰 배열 안에 있습니다. 그러나 표시되지 않으며 다른 정렬된 보기의 레이아웃에 영향을 주지 않습니다.\n-   스택의 정렬된 뷰 배열에 뷰를 추가하면 뷰 계층 구조에 자동으로 추가됩니다.\n-   스택의 정렬된 뷰 배열에서 뷰를 제거해도 뷰 계층에서 자동으로 제거되지 않습니다. 그러나 뷰 계층 구조에서 뷰를 제거하면 정렬된 보기 뷰에서 제거됩니다.\n-   iOS에서 보기의 hidden 속성은 일반적으로 애니메이션할 수 없습니다. 그러나 이 속성은 뷰가 스택의 정렬된 뷰 배열에 배치되는 즉시 뷰에 대해 애니메이션 가능해집니다. 실제 애니메이션은 뷰가 아닌 스택에서 관리합니다. hidden 속성을 사용하여 뷰를 스택에 추가하거나 스택에서 제거하는 애니메이션을 만듭니다.\n\n이 예시는 또한 스크롤 뷰와 함께 자동 레이아웃을 사용하는 아이디어를 소개합니다. 여기서 스택과 스크롤 뷰 사이의 제약 조건은 스크롤 뷰의 콘텐츠 영역 크기를 설정합니다. 동일한 너비 제약 조건은 명시적으로 스택(및 콘텐츠 크기)을 설정하여 스크롤 뷰를 가로로 채웁니다. 수직으로 콘텐츠 크기는 스택의 피팅 크기를 기반으로 합니다. 사용자가 더 많은 항목을 추가하면 스택 뷰가 길어집니다. 콘텐츠가 너무 많아 화면에 표시되지 않는 즉시 스크롤이 자동으로 활성화됩니다.\n\n자세한 내용은 [Working with Scroll Views](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithScrollViews.html#//apple_ref/doc/uid/TP40010853-CH24-SW1)을 참조하세요.\n\n&nbsp;\n&nbsp;\n"},"__N_SSG":true}